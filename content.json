{"meta":{"title":"Capisy","subtitle":"WELCOME TO MY BLOG.","description":"capisy.cn，web前端，全栈，koa，eggjs，vue，react，https://capisy.cn","author":"MF","url":"https://capisy.github.io"},"pages":[{"title":"","date":"2020-03-01T14:22:53.455Z","updated":"2020-03-01T14:22:53.455Z","comments":true,"path":"404.html","permalink":"https://capisy.github.io/404.html","excerpt":"","text":""},{"title":"Archives","date":"2017-03-20T12:49:56.000Z","updated":"2020-03-01T14:22:53.468Z","comments":false,"path":"archive/index.html","permalink":"https://capisy.github.io/archive/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-03-01T14:22:53.475Z","updated":"2020-03-01T14:22:53.475Z","comments":true,"path":"tags/index.html","permalink":"https://capisy.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"EXCEL常用函数汇总","slug":"excel-func","date":"2020-03-01T01:07:00.000Z","updated":"2020-03-01T15:19:49.516Z","comments":true,"path":"2020/03/01/excel-func/","link":"","permalink":"https://capisy.github.io/2020/03/01/excel-func/","excerpt":"","text":"把首字母转换为大写 proper1=proper(text) 快速生成26个英文字母 char1=char(row(a65)) // A,然后ctrl下拉，同数字递增 1=char(row(a97)) // a 字符串合并 phonetic","categories":[],"tags":[{"name":"excel","slug":"excel","permalink":"https://capisy.github.io/tags/excel/"}]},{"title":"面向对象-继承和多态","slug":"php-oop-6","date":"2019-08-09T11:20:00.000Z","updated":"2020-03-01T14:22:53.464Z","comments":true,"path":"2019/08/09/php-oop-6/","link":"","permalink":"https://capisy.github.io/2019/08/09/php-oop-6/","excerpt":"","text":"继承不能简单的理解成子类定义时，会把父类的属性声明、方法定义拷贝一份，而是建立了继承查找的关系。 在创建某个子类对象时，如果子类没有定义构造函数，则会调用父类的构造函数。如果子类定义了构造函数，则会覆盖父类的构造函数。 子类调用父类方法的两种方式123456class Father&#123; function __construct()&#123;&#125; function sayHello()&#123; echo 'Hello !'; &#125;&#125; 123456class Child extends Father&#123; function __construct()&#123; $this-&gt;sayHello(); // 方法一 parent::sayHello(); // 方法二 &#125;&#125; // 但是不能用方法一（$this）调用父类的__construct构造函数，会递归调用，死循环 方法重载 通过魔术方法实现动态的创建属性和方法 12345678910111213141516171819202122232425class Reload&#123; private function sum($args)&#123; list($n1,$n2) = $args; return $n1 + $n2; &#125; private function getMax($args)&#123; return max($args); &#125; public function __call($method,$args)&#123; var_dump($args); if($method ==='getVal')&#123; if(count($args)===2)&#123; return $this-&gt;sum($args); &#125;else &#123; return $this-&gt;getMax($args); &#125; &#125; &#125;&#125;$r1 = new Reload;$r1-&gt;getVal(30,40); // 求和$r1-&gt;getVal(30,40,50); // 求最大值 属性重载123456789101112131415class Person&#123; private $prop_array = array(); function __set($prop_name,$val)&#123; $this-&gt;prop_array[$prop_name] = $val; &#125; function __get($prop_name)&#123; if(isset($this-&gt;$prop_array[$prop_name]))&#123; return $this-&gt;$prop_array[$prop_name] &#125;else &#123; return '属性不存在'; &#125; &#125;&#125; 方法重写 如果子类需要访问父类的方法 12345class Animal&#123; function cry()&#123; echo '父类的cry方法...'; &#125;&#125; 如果子类不含有父类的方法 123456class Cat extends Animal&#123; function cry2()&#123; parent::cry(); // 第一种调用方式 $this-&gt;cry(); // 第二种调用方式 &#125;&#125; 如果子类含有父类的方法 12345class Dog extends Animal&#123; function cry()&#123; parent::cry(); &#125;&#125; // 如果使用$this的方式调用就会递归死循环 注意事项1.子类方法的参数个数、参数名称要和父类方法的参数个数、参数名称保持一致 2.如果父类方法的参数使用了类型约束，还必须保证数据类型一致 12345class A &#123; function mergeArr(array $arr1, array $arr2)&#123; return array_merge($arr1,$arr2); &#125;&#125; 12345class B extends A &#123; function mergeArr(array $arr1, array $arr2)&#123; echo '重写父类的mergeArr'; &#125;&#125; 3.子类方法不能缩小父类方法的访问权限 123class A &#123; protected function foo()&#123;&#125;&#125; 123class B extends A &#123; public function foo()&#123;&#125;&#125; 多态 在面向对象中，对象在不同情况下的多种状态。 123456789101112class Animal&#123; public $name; function __construct($name)&#123; $this-&gt;name =$name; &#125; function showInfo()&#123; return $this-&gt;name; &#125;&#125;class Cat extends Animal&#123;&#125;class Dog extends Animal&#123;&#125; 123456789101112class Food&#123; public $food; function __construct($food)&#123; $this-&gt;food = $food; &#125; function showFood()&#123; return $this-&gt;food; &#125;&#125;class Fish extends Food&#123;&#125;class Bone extends Food&#123;&#125; 12345class Master&#123; function feed(Animal $animal, Food $food)&#123; echo '&lt;br&gt;'.$animal-&gt;showInfo() . '喜欢吃' . $food-&gt;showFood(); &#125;&#125; 123456789$c1 = new Cat('波斯猫');$d1 = new Dog('二哈');$f1 = new Fish('&lt;・)))&gt;&lt;&lt;');$b1 = new Bone('骨头');$xiaobai = new Master;$xiaobai-&gt;feed($c1,$f1);$xiaobai-&gt;feed($d1,$b1);","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://capisy.github.io/tags/php/"}]},{"title":"面向对象-封装","slug":"php-oop-5","date":"2019-08-07T11:16:00.000Z","updated":"2020-03-01T14:22:53.463Z","comments":true,"path":"2019/08/07/php-oop-5/","link":"","permalink":"https://capisy.github.io/2019/08/07/php-oop-5/","excerpt":"","text":"封装php提供三种访问控制符来控制方法和属性的访问权限 public protected private 类内部 true true true 继承类 true true false 类外部 true false false 访问和修改受保护和私有属性的方法使用魔术方法1234567891011121314151617181920212223class Person&#123; protected $age; private $salary; function __construct($age,$salary)&#123; $this-&gt;age = $age; $this-&gt;salary = $salary; &#125; function __get($prop)&#123; if(isset($this-&gt;$prop))&#123; return $this-&gt;$prop; &#125; &#125; function __set($prop,$val)&#123; if(isset($prop))&#123; $this-&gt;$prop = $val; &#125; &#125;&#125;$p1 = new Person(16,99999);echo $p1-&gt;age; // 16$p1-&gt;salary = 100000;echo $p1-&gt;salary; // 100000 通过 getX 和 setX 方法1234567891011121314151617181920212223class Book &#123; private $amount; // 销量 function __construct($amount)&#123; $this-&gt;amount = $amount; &#125; function setAmount($num)&#123; if(is_int($num))&#123; $this-&gt;amount = $num; &#125;else&#123; echo '请输入一个数字'; &#125; &#125; function getAmount($validate)&#123; if($validate)&#123; return $this-&gt;amount; &#125;else&#123; echo '没有访问权限'; &#125; &#125;&#125; 对象运算符的链式调用123456789101112131415161718192021222324252627282930313233343536373839class Student &#123; private $school; function setSchool($school)&#123; $this-&gt;school = $school; &#125; function getSchool()&#123; return $this-&gt;school; &#125;&#125;class School&#123; private $myClass; function setClass($class)&#123; $this-&gt;myClass= $class; &#125; function getClass()&#123; return $this-&gt;myClass; &#125;&#125;class MyClass&#123; public $className;&#125;$myClass = new MyClass;$myClass-&gt;className ='ub2010';$school = new School;$school-&gt;setClass($myClass);$zcj = new Student;$zcj-&gt;setSchool($school);$className = $zcj-&gt;getSchool()-&gt;getClass()-&gt;className;echo $className; // ub2010","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://capisy.github.io/tags/php/"}]},{"title":"面向对象-类的静态属性和静态方法","slug":"php-oop-4","date":"2019-08-06T11:47:00.000Z","updated":"2020-03-01T14:22:53.463Z","comments":true,"path":"2019/08/06/php-oop-4/","link":"","permalink":"https://capisy.github.io/2019/08/06/php-oop-4/","excerpt":"","text":"静态属性 定义：静态属性是该类所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也都是同一个变量。 声明一个含有静态属性的类1234567891011121314151617class Player&#123; public static $player_count = 0; // 静态属性（public访问修饰符可以省略） function __construct($name)&#123; $this-&gt;name = $name; &#125; function addPlayer()&#123; echo(\"&#123;$this-&gt;name&#125;加入游戏&lt;br/&gt;\"); self::$player_count++; &#125; function getTotalPlayer()&#123; return self::$player_count; &#125;&#125; 实例化类，获取静态属性的值12345678$p1 = new Player('李狗蛋');$p1-&gt;addPlayer(); // 李狗蛋加入游戏$p2 = new Player('王小花');$p2-&gt;addPlayer(); // 王小花加入游戏 echo '参加游戏人数：' . Player::$player_count; // 2 echo \"当前游戏人数：&#123;$p1-&gt;getTotalPlayer()&#125;\"; // 2 self 和 $this 的区别 self 是类的范畴（指向类） $this 是对象实例 （指向对象实例） 静态方法声明和调用1234567class Person&#123; public static function sayHello()&#123; echo 'Hello!'; &#125;&#125;Person::sayHello(); 1234567891011121314151617181920class Worker&#123; static $productions =0; static function product($num)&#123; self::$productions += $num; &#125; static function getProductions()&#123; return self::$productions; &#125;&#125;$w1 = new Worker;$w1-&gt;product(5.5);$w2 = new Worker;$w2-&gt;product(6);echo 'Productions:'. Worker::getProductions(); // Productions:11.5 注意事项 成员方法可以使用静态属性，但是静态方法不能使用成员属性 123456789class Person&#123; public $name='shiyuan'; static function showName()&#123; echo $name; &#125;&#125;Person::showName(); // Undefined variable: name 静态方法也不调用非静态方法（成员方法） 1234567891011class Person&#123; static function execFunc()&#123; $this-&gt;sayHello(); &#125; function sayHello()&#123; echo 'Hello !'; &#125;&#125;Person::execFunc(); // 在执行上下文找不到$this 使用静态方法实现单例模式12345678910111213141516171819202122class DBHelper &#123; private static $instance = null; private function _construct()&#123; $this-&gt;conn = '数据库连接'; &#125; private function __clone()&#123;&#125; public static function getSingleton()&#123; if(!(self::$instance instanceof self))&#123; self::$instance = new self(); &#125; return self::$instance; &#125; public function execQuery($sql)&#123; echo '数据库操作'; &#125;&#125;$db = DBHelper::getSingleton();","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://capisy.github.io/tags/php/"}]},{"title":"面向对象-类的自动加载","slug":"php-oop-3","date":"2019-08-05T12:45:00.000Z","updated":"2020-03-01T14:22:53.462Z","comments":true,"path":"2019/08/05/php-oop-3/","link":"","permalink":"https://capisy.github.io/2019/08/05/php-oop-3/","excerpt":"","text":"基础用法 当使用一个没有定义的类时，就会自动触发 spl_autoload_register 方法 123spl_autoload_register(function($class)&#123; include 'classes/' . $class . '.class.php';&#125;); 优化方案定义一个类的映射数组1234$class_map = array( 'Person'=&gt;'model/person', 'Config'=&gt;'lib/config',); 调用 spl_autoload_register 方法1234spl_autoload_register(function($class)&#123; global $class_map; include $class_map[$class] . '.class.php';&#125;);","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://capisy.github.io/tags/php/"}]},{"title":"面向对象-访问修饰符","slug":"php-opp-2","date":"2019-08-04T12:32:00.000Z","updated":"2020-03-01T14:22:53.464Z","comments":true,"path":"2019/08/04/php-opp-2/","link":"","permalink":"https://capisy.github.io/2019/08/04/php-opp-2/","excerpt":"","text":"访问修饰符定义 对属性或方法的访问控制，通过在前面添加关键字来是实现 public-公有：可以在任何地方被访问 protected-受保护: 可以被自身及其子类或父类访问 private-私有：只能被其定义所在的类访问 12345678910111213141516class Clerk &#123; public $name; protected $job; private $salary; function __construct($name,$job,$salary)&#123; $this-&gt;name = $name; $this-&gt;job= $job; $this-&gt;salary=$salary; &#125;&#125;$c1 = new Clerk('shiyuan','actor','99999');echo($c1-&gt;name);echo($c1-&gt;job); // Cannot access protected propertyecho($c1-&gt;salary); // Cannot access private property 通过公有的成员方法,访问受保护的和私有的属性123456789101112131415161718192021class Clerk &#123; protected $job; private $salary; function __construct($job,$salary)&#123; $this-&gt;job= $job; $this-&gt;salary=$salary; &#125; function showJob()&#123; return $this-&gt;job; &#125; function showSalary()&#123; return $this-&gt;salary; &#125;&#125;$c2 = new Clerk('shiyuan','actor','99999');echo($c2-&gt;showJob()); // actorecho($c2-&gt;showSalary()); // 99999","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://capisy.github.io/tags/php/"}]},{"title":"面向对象-类的定义","slug":"php-oop-1","date":"2019-08-03T01:57:01.000Z","updated":"2020-03-01T14:22:53.462Z","comments":true,"path":"2019/08/03/php-oop-1/","link":"","permalink":"https://capisy.github.io/2019/08/03/php-oop-1/","excerpt":"","text":"定义一个类123class Person &#123; public $name;&#125; 对象传递机制12345678$p1 = new Person; // 如果在实例化对象时没有参数，可省略括号$p1-&gt;name = 'old name';$p2 = $p1;echo $p2-&gt;name; // 'old name'$p1-&gt;name = 'new name';echo $p2-&gt;name; // 'new name' 如果是引用传递123$p3 = &amp;$p1;$p3 = 'shiyuan';echo $p1; // shiyuan 成员方法12345678910111213class Person&#123; public function calc($num=10)&#123; $res =0; for($i=1;$i&lt;=$num;$i++)&#123; $res+=$i; &#125; return $res; &#125;&#125;$p4 = new Person;echo($p4-&gt;calc()); //55echo($p4-&gt;calc(100)); // 5050 构造函数 作用：完成新对象实例的初始化 特点： （1）没有返回值 （2）在创建新实例时，系统会自动调用 （3）构造函数的访问修饰符可以省略 （4）如果没有定义，系统会自动生成一个空的构造函数 12345678class Person &#123; public function __construct($name)&#123; $this-&gt;name = $name; &#125;&#125;;$p5 = new Person('shiyuan');echo($p5-&gt;name); // shiyuan 成员方法中调用构造函数中的属性1234567891011class Person &#123; function __construct($name)&#123; $this-&gt;name = $name; &#125; public function showName()&#123; return $this-&gt;name; &#125;&#125;;$p6 = new Person('十元');echo($p6-&gt;showName()); // 十元 析构函数 析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 12345678910class Person &#123; function __construct($name)&#123; $this-&gt;name = $name; &#125; function __destruct()&#123; print \"Destroying \" . $this-&gt;name . \"\\n\"; &#125;&#125;;$p7 = new Person('shiyuan'); 析构函数的用途 (用于当前文件代码量较大时) 希望在程序没有结束前，及时销毁对象创建的资源，eg：数据库连接 1234567891011121314class HeavySource&#123; function __construct($source)&#123; $this-&gt;source=$source; &#125; function __destruct()&#123; // 手动销毁 heavy source &#125;&#125;$s1 = new HeavySource('heavy source');........$sl = null; // 释放资源........ php中的垃圾回收机制垃圾是如何定义的 判断是否为垃圾，主要看有没有变量指向变量容器zval，如果没有则认为是垃圾，需要释放。 老版本中如何产生内存泄漏垃圾 环形引用 12$a = ['one'];$a[] = &amp;$a; 解决方法（GC算法） 对zval中的每一个元素进行一次refcount减一操作，操作完成后，如果zval的refcount=0，那么zval就是一个垃圾","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://capisy.github.io/tags/php/"}]},{"title":"swiper滚屏爬坑","slug":"vue-swiper","date":"2019-07-17T03:18:55.000Z","updated":"2020-03-01T14:22:53.467Z","comments":true,"path":"2019/07/17/vue-swiper/","link":"","permalink":"https://capisy.github.io/2019/07/17/vue-swiper/","excerpt":"","text":"需求 全屏滚动，不是第一屏的时候显示 header 问题 系统的 scrollTop 会被禁用 监听 this.$refs.mouseWheel.swiper,这里的 activeIndex 不会实时更新 解决方案 引入 swiper 123456import Vue from \"vue\";import VueAwesomeSwiper from \"vue-awesome-swiper\";import \"swiper/dist/css/swiper.css\";Vue.use(VueAwesomeSwiper);export default VueAwesomeSwiper; 封装 mouse-wheel 组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;template&gt; &lt;swiper :options=\"swiperOption\" class=\"mouse-wheel\" ref=\"mouseWheel\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;div class=\"swiper-pagination\" slot=\"pagination\"&gt;&lt;/div&gt; &lt;/swiper&gt;&lt;/template&gt;&lt;script&gt;import '@/plugin/swiper'import &#123; mapMutations &#125; from 'vuex'let texport default &#123; name: 'mouseWheel', created() &#123; t = this &#125;, data() &#123; return &#123; swiperOption: &#123; direction: 'vertical', slidesPerView: 1, mousewheel: true, speed: 400, pagination: &#123; el: '.swiper-pagination', clickable: true, &#125;, on: &#123; init() &#123; t.swiper = this &#125;, slideChangeTransitionEnd: function() &#123; const curIdx = t.swiper.activeIndex t.SWIPER_INDEX(curIdx) &#125;, &#125;, &#125;, &#125; &#125;, methods: &#123; ...mapMutations(['SWIPER_INDEX']), &#125;,&#125;&lt;/script&gt;&lt;style lang=\"scss\"&gt;$color: #d2d4d6;.mouse-wheel &#123; height: 100vh; .swiper-pagination &#123; display: flex; flex-direction: column; align-items: center; &#125; .swiper-pagination-bullet &#123; width: 12px; height: 12px; background-color: $color !important; opacity: 1 !important; &#125; .swiper-pagination-bullet-active &#123; width: 20px; height: 20px; border: 3px solid $color; background: none !important; &#125;&#125;&lt;/style&gt; 调用 mouse-wheel 组件 1234567891011&lt;template&gt; &lt;v-mouse-wheel&gt; &lt;swiper-slide&gt; &lt;v-header /&gt; &lt;v-banner /&gt; &lt;/swiper-slide&gt; &lt;swiper-slide&gt; &lt;v-investment /&gt; &lt;/swiper-slide&gt; &lt;/v-mouse-wheel&gt;&lt;/template&gt; 手动触发（header 组件中锚点指向某屏） 12345678910computed: &#123; swiper() &#123; return this.$parent.$parent.$parent.$refs.mouseWheel.swiper &#125;,&#125;,methods: &#123; moveToSlide(idx) &#123; this.swiper.slideTo(idx, 500, false) &#125;,&#125;,","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://capisy.github.io/tags/vue/"}]},{"title":"create-react-app按需加载antd","slug":"react-antd-demand-loading","date":"2019-04-08T07:07:42.000Z","updated":"2020-03-01T14:22:53.465Z","comments":true,"path":"2019/04/08/react-antd-demand-loading/","link":"","permalink":"https://capisy.github.io/2019/04/08/react-antd-demand-loading/","excerpt":"","text":"下载依赖包 12yarn add less less-loader -Syarn add babel-plugin-import -D 配置package.json 1234567\"plugins\": [ [\"import\", &#123; \"libraryName\": \"antd\", \"libraryDirectory\": \"es\", \"style\": true &#125;] ] 配置webpack.config.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 1.增加less支持模块const lessRegex = /\\.less$/;const lessModuleRegex = /\\.module\\.less$/;// 2.照猫画虎，把sass相关的配置复制一份，改成less&#123; test: lessRegex, exclude: sassModuleRegex, use: getStyleLoaders( &#123; importLoaders: 2, sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, &#125;, 'less-loader' ), sideEffects: true, &#125;,&#123; test: lessModuleRegex, use: getStyleLoaders( &#123; importLoaders: 2, sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, modules: true, getLocalIdent: getCSSModuleLocalIdent, &#125;, 'less-loader' ), &#125;,// 3.修改一下less的preProcessor配置项，加入antd配置if (preProcessor) &#123; let loader = &#123; loader: require.resolve(preProcessor), options: &#123; sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, &#125; &#125; if (preProcessor === \"less-loader\") &#123; loader.options.modifyVars = &#123; 'primary-color': 'green', 'link-color': '#1DA57A', 'border-radius-base': '2px', &#125; loader.options.javascriptEnabled = true &#125; loaders.push(loader);&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://capisy.github.io/tags/react/"}]},{"title":"基础-数据库操作","slug":"php-pdo","date":"2019-04-06T15:25:00.000Z","updated":"2020-03-01T14:22:53.464Z","comments":true,"path":"2019/04/06/php-pdo/","link":"","permalink":"https://capisy.github.io/2019/04/06/php-pdo/","excerpt":"","text":"mysql连接 dsn:data source name 12345678910111213$db = [ 'dsn'=&gt;'mysql:host=localhost;dbname=mf_demo;port=3306', 'name' =&gt; 'root', 'passwd'=&gt;'m123456', 'opts' =&gt; [PDO::ATTR_ERRMODE=&gt;PDO::ERRMODE_EXCEPTION] // 可选：调优参数 ]; try&#123; $pdo = new PDO($db['dsn'],$db['name'],$db['passwd'],$db['opts']); &#125;catch(PDOException $e)&#123; echo $e-&gt;getMessage(); exit; &#125; pdo执行sql语句的三种方法query(),执行select语句，返回结果集 1234567try&#123; $select_sql = \"select * from mf_loving\"; $stmt = $pdo-&gt;query($select_sql); print_r($stmt);&#125;catch(PDOException $e)&#123; $e-&gt;getMessage();&#125; exec(),执行update，delete，insert..返回影响的行数 1234567try&#123; $update_sql = \"update mf_loving set name = 'shiyuan' where id = 6\"; $affected_rows = $pdo-&gt;exec($update_sql); echo '执行成功，影响行数:' . $affected_rows; &#125;catch(PDOException $e)&#123; echo $e-&gt;getMessage(); &#125; prepare(),可执行所有的sql语句 1234567$update_sql = \"update mf_loving set name = ? where id = ?\";$stmt = $pdo-&gt;prepare($update_sql);try&#123; $res = $stmt-&gt;execute(['shiyuan',6]);&#125;catch(PDOException $e)&#123; echo $e-&gt;getMessage(); &#125; 常用stmt方法12345/*** 设置获取数据的模式* @ params: PDO::FETCH_NUM 或 PDO::FETCH_ASSOC*/$stmt-&gt;setFetchMode(PDO::FETCH_NUM); 12$data = $stmt-&gt;fetch(); // 一条数据 $data = $stmt-&gt;fetchAll(); // 所有数据 12$rowLen = $stmt-&gt;rowCount(); // 获取数据的行数$columnLen = $stmt-&gt;columnCount(); // 获取字段数 1234567// 获取返回数据的字段信息 $fileds = []; for($i=0; $i&lt;$columnLen; $i++)&#123; $filed = $stmt-&gt;getColumnMeta($i); array_push($fileds,$filed['name']); &#125; print_r($fileds); 常用的pdo方法12// 获取最后插入的ID$last_insert_id = $pdo-&gt;lastInsertId(); 事务处理1234567891011121314151617181920try&#123; // 开启事务处理 $pdo-&gt;beginTransaction(); $price = 50; $sql = \"update mf_account set account =account+ ? where name = ?\"; $stmt = $pdo-&gt;prepare($sql); // 张三转出 $affected_rows = $stmt-&gt;execute([-$price,'zhangsan']); echo ($affected_rows ? $affected_rows : '张三转出失败') . '&lt;br&gt;'; // 李四转入 $affected_rows = $stmt-&gt;execute([$price,'lisi']); echo ($affected_rows ? $affected_rows : '李四转出失败') . '&lt;br&gt;'; // 无错误，提交事务 $pdo-&gt;commit(); echo '交易成功'; &#125;catch(PDOException $e)&#123; echo $e-&gt;getMessage(); // 有错误，回滚操作 $pdo-&gt;rollback(); &#125;","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://capisy.github.io/tags/php/"}]},{"title":"Redis-CRUD","slug":"redis-primary","date":"2019-04-01T09:25:02.000Z","updated":"2020-03-01T14:22:53.465Z","comments":true,"path":"2019/04/01/redis-primary/","link":"","permalink":"https://capisy.github.io/2019/04/01/redis-primary/","excerpt":"","text":"安装1https://redis.io/download 1234wget http://download.redis.io/releases/redis-5.0.4.tar.gztar xzf redis-5.0.4.tar.gzcd redis-5.0.4make 修改配置文件 安装目录 redis.conf 12daemonize yes // 后台启动，默认为noport 6379 // 这个不建议改 如果想要远程连接redis，需要更改下面两项配置 12# bind 127.0.0.1 // 注释掉protected-mode no // 默认为yes redis 启动服务 我的配置文件目录：/usr/loca/src/redis/ 12redis-server // 默认启动redis-server redis.conf // 在redis的配置文件目录用配置文件启动 redis 客户端关闭和启动123redis-cli shutdown // 关闭redis-cli -h 10.0.1.188 -p 6379 // 开启redis-cli -h 10.0.1.188 -p 6379 --raw // 可以识别中文 redis 数据操作查看所有数据的key值 1keys * 清空所有数据 1flushall 字符串添加 12set key val // set name yjyget key // get name-&gt; &apos;yjy&apos; 查看 12mset key val [key val] // mset n1 a n2 b n3 cmget key [key]// mget n1 n2 n3 -&gt; &apos;a&apos; &apos;b&apos; &apos;c&apos; 更改 12345set age 20 incr age // 21decr age // 20incrby age 10 // 30decrby age 5 // 25 123append key val // 追加append name -aaaget name // &apos;yjy-aaa&apos; 删除 1del name // 删除操作 list12345lpush key val [val] // 插入一个或多个数据lpop key // 删除数据，并返回删除的值llen key // 获取list的长度lrange books [start,end] // 获取范围内list的值lrange books 0 -1 // 获取list中所有的值 hash添加 1hset hashName key val // drinks:&#123; coffee: latte &#125;，一次可以存多个值 查看 1234hget drinks coffee // 一次只能取一个值hgetall drinks // 一次返回所有值，key value key value... 形式hvals drinks // 查看所有值hkeys drinks // 查看所有字段 修改 1234// 对hash内的数值型字段做增（10）减（-10）hset xiaomin age 20hincrby xiaomin age 10 // 没有decrby命令hget xiaomin age // 30 删除 1del name key // 删除操作，可以一次删掉多个 判断是否存在 1hexists drink water // 判断hash是否存在某个字段，返回1或0 set添加 12sadd key val [val] sadd books js php linux 查看 12smembers keysmebers books 判断是否是成员 1sismember key value 随机取出n个成员 12srandmember key amountsrandmember books 3 两个集合之间的操作 123sdiff key1 key2 // 差集运算sinter key1 key2 // 交集运算sunion key1 key2 // 并集运算 有序集合添加 123zadd key power valuezadd code_lang 10000 jszadd code_lang 5000 php 查询 12zcard key // 查询个数zcard code_lang // 3 1234zrange key start end // 范围查询zrevrange key start end // 反向查询zrange code_lang 0 -1 // 查询code_lang 中所有的成员zrange code_lang 0 -1 withscores // 查询所有成员及权重 12zrangebyscore key min max zrangebyscore code_lang -inf 2000 // 负无穷到2000内的成员 删除 12zrem key val [val]zrem code_lang java 过期时间以秒为单位 12expire key timeexpire xiaomin 50 查看剩余秒数 12ttl keyttl xiaoming setex 设置是加时间 12setex key time val // 只有set可以在设置是加时间setex schook 100 antu 事务123456multi // 事务开始 incr ageincr age ....exec // 事务结束discard // 回滚","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"https://capisy.github.io/tags/redis/"}]},{"title":"基础-函数篇","slug":"php-func","date":"2019-03-31T13:35:02.000Z","updated":"2020-03-01T14:22:53.462Z","comments":true,"path":"2019/03/31/php-func/","link":"","permalink":"https://capisy.github.io/2019/03/31/php-func/","excerpt":"","text":"设置文件头信息1header('content-type:text/html;charset=utf-8'); 日期、时间函数设置当前时区为中国 1date_default_timezone_set('PRC'); 时间戳 1time(); 获取日期时间 123$cur_date = date('Y-m-d H:i:s');// 根据时间戳获取时间$special_date = data('Y-m-d H:i:s',time()); 获取星期信息 123$arr_days = ['星期日','星期一','星期二','星期三','星期四','星期五','星期六'];$today_day = date('w'); // 获取当前是一个星期的第几天echo \"今天是&#123;$arr_day[$today_day]&#125;\"; 数学函数123// 随机数函数mt_rand(min,max);echo mt_rand(0,255); 1234567// 取整函数$num_ceil = ceil(3.14) // 4$num_floor = floor(3.14) // 3// @ param1:需要四色五入的数// @ param2:保留到小数点后几位$num_round = round(3.1419526,2); // 3.14 123//最大值和最小值$max = max(1,2,3); // 3 $min = min(1,2,3); // 1 1234// 数字格式化，以千位分隔符形式转换// @ params1: 格式化的数// @ params2：保留到小数点后几位$format_num = number_format(111222333.444555,2); // 111,222,333.44 字符串相关的函数123// 获取字符串长度$str = 'mfyj';$len = strlen($str) 123456// 字符串大小写转换$str = 'wish you have a good ending ';$toUpper = strToUpper($str);$toLower = strToLower($str);$ucFirst = ucFirst($str); // 句子的首字母转换为大写$ucWords = ucWords($str); // 句子的每个单词首字母转换为大写 1234567// 字符串替换$str = 'mdZz';$str2 = str_replace('z',' hello',$str); // 区分大小写$str3 = str_ireplace('z',' hello',$str); // 不区分大小写echo $str2; // mdZ helloecho $str3; // md hello helloecho $str; // mdZz 1$html = htmlSpecialChars($str); // 转换html中的标签 1234// 删除收尾空格,不会改变原来的字符串$str2 = lTrim($str);$str3 = rTrim($str);$str4 = trim($str); 123// 获取当前字符在字符串中第一次出现的位置,类似js中的indexof$pos = strPos('javascript','t'); // 区分大小写$posIgnore = striPos('javascript','T'); // 不区分大小写 123// 字符串截取// @ param $end：可选参数，缺省为到字符串末尾$subStr = subStr($str,$start,$end); 12// 字符串反转$str2 = strRev('javascript'); 12// 字符串md5$str_md5 = md5($str); 12// 字符串打乱$str_shuffle = str_shuffle('abcdef'); 1234567// 字符串分割// @ param1: 分隔符// @ param2: 被分割的字符串// @ ret: []$str_arr = explode(' ',$str);// 数组的拼接$str = implode('',$str_arr); 12 局部静态变量1234function foo()&#123; static $var = 0; $var++;&#125; 用js代码表示 123456const foo = (function()&#123; let _var = 0 return function()&#123; _var++ &#125;&#125;()) 全局变量12345678$a = 1;$b = 2;function global_var()&#123; global $a,$b; // 函数内部使用全局变量需要先声明 $a = 3; // 函数内部可以改变全局变量的值&#125;global_var();echo $a; // 3 引用传递,可以理解为变量的浅拷贝（地址引用） 123456$a = 1;functon foo(&amp;$a)&#123; $a = 2;&#125;foo($a);echo $a; // 2 1234567$obj = new StdClass()$obj-&gt;a = 3;function fun($o)&#123; $o-&gt;b = 4;&#125;fun($obj);print_r($obj); // a=3,b=4 函数参数可以设置默认值 设置默认值的变量必须放到最后 123function foo($a=3,$b=4)&#123; echo $a,$b;&#125; 可变参数12345function foo()&#123; print_r(func_get_args()); // [1,2,3] echo func_num_args; // 参数数量&#125;foo(1,2,3); 用js代码表示 1234function foo()&#123; let args = arguments console.log(args,args.length)&#125; 参数类型 可选参数： array、stdClass、callable（回调函数）在指定了参数类型后，如果参数类型不匹配程序会报错 1234function foo(array $arr)&#123; print_r($arr);&#125;foo([1,2,3]) 函数嵌套 php中所有函数都是全局作用域如果要在全局调用函数内部嵌套的函数，需要先执行外部的函数 1234567function foo()&#123; function bar()&#123; echo 'MDZZ,傻逼才会这么用函数'; &#125;&#125;foo();bar(); 嵌套函数如果想使用局部变量，需要使用匿名函数use传值的方式 123456789function foo()&#123; $var = 1; $bar = function() use($var)&#123; echo $var; // 1 &#125;; $bar();&#125;;foo(); 12345678910function foo()&#123; $var = '局部变量'; return function($out) use($var)&#123; echo $out; // 外部传入的参数 echo $var; // 局部变量 &#125;;&#125;;$res_fn = foo();$res_fn('外部传入的参数');","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://capisy.github.io/tags/php/"}]},{"title":"基础-数据类型","slug":"php-datatype","date":"2019-03-31T03:41:44.000Z","updated":"2020-03-01T14:22:53.461Z","comments":true,"path":"2019/03/31/php-datatype/","link":"","permalink":"https://capisy.github.io/2019/03/31/php-datatype/","excerpt":"","text":"一次声明多个变量句尾；不能省略，js狗比中指 1$a=$b=$c = 123; 一次打印多个变量12echo $a,$b,$c;var_dump($a,$b,$c); 字符串类型 单引号不解析变量，也不解析转义字符 双引号中的变量用{}包裹（不会出错的写法） 双引号解析转义字符 单引号和双引号都可以解析html标签 123echo '\\$a&lt;br/&gt;';echo \"\\$a&lt;br/&gt;\";echo \"&#123;\\$a&#125;&lt;/br&gt;\"; 定界符 123$str=&lt;&lt;&lt;dog 'I'm a coding dog~~'dog; 验证变量变量不存在的时候不会报错 12345if(isset($_GET['loving']))&#123; echo $_GET['loving'];&#125;else &#123; echo 0;&#125; 验证数组 数组必须存在 不需要验证count（$loving）123456$loving = [];if(!empty($loving))&#123; echo '1';&#125;else &#123; echo '0';&#125; list函数对变量解构赋值 只能对索引数组解构 不会影响原数组 对标js的语法弱爆了1234$loving = ['sleep','foot ball','movie'];list($ty1,$ty2,$ty3) = $loving;echo $ty1.\"&lt;br/&gt;\".$ty2.\"&lt;br/&gt;\".$ty3.\"&lt;br/&gt;\";dump($loving); 临时类型转换不会对原变量产生影响 12345$var_int = (int)$var;$var_float = (float)$var;$var_str = (string)$var;$var_bool = (bool)$var;$var_null = (unset)$var; 永久类型转换123settype($var,'bool');// 可以设置的类型// int,float,string,int,bool,array,object,null 判断变量的类型12345678910is_int($var);is_float($var);is_string($var);is_bool($var);is_scalar($var); // 标量is_null($var);is_array($var);is_object($var);is_resource($var);is_numeric($var); // 是否为数值型或字符串型的数字","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://capisy.github.io/tags/php/"}]},{"title":"nginx小记","slug":"nginx-primary","date":"2019-03-30T07:03:41.000Z","updated":"2020-03-01T14:22:53.461Z","comments":true,"path":"2019/03/30/nginx-primary/","link":"","permalink":"https://capisy.github.io/2019/03/30/nginx-primary/","excerpt":"","text":"安装查看nginx是否安装 1yum info nginx 官网下载 12345678vi /etc/yum.repos.d/nginx.repo[nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=1enabled=1gpgkey=https://nginx.org/keys/nginx_signing.key 查看安装源是否生效,安装 12yum list|grep nginxyum install nginx -y 安装成功，启动nginx 12service nginx status // 查看是否开启servicee nginx start // 打开服务 查看nginx安装path 1which nginx 配置nginx项目目录把root改成你想配置的目录给自定义的目录设置755权限更新配置 1kill -HUP `cat /var/run/nginx.pid` 如果访问页面是403错误查看SELinux设置状态 1/usr/sbin/sestatus 如果是enfing，修改为disabled 123vi /etc/selinux/configSELINUX = disabledreboot 配置本地域名更改serve_name 1server_name mf.com; 更改window的host文件 110.0.1.188 mf.com // 10.0.1.188 为虚拟机的ip 反向代理，解决前后端分离项目跨域问题1234location /api &#123; rewrite ^/api/(.*)$ /$1 break; proxy_pass http://api.kylin.eosbeijing.one:8880;&#125; nginx配置,支持前端browser路由123456789location / &#123; root /var/www/eos_game_build; try_files $uri $uri/ @router; index index.html index.htm;&#125; location @router&#123; rewrite ^.*$ /index.html last;&#125;","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://capisy.github.io/tags/nginx/"}]},{"title":"Object.defineProperty实现双向数据绑定","slug":"vue-principle-1","date":"2018-10-05T11:07:00.000Z","updated":"2020-03-01T14:22:53.466Z","comments":true,"path":"2018/10/05/vue-principle-1/","link":"","permalink":"https://capisy.github.io/2018/10/05/vue-principle-1/","excerpt":"","text":"原理12&lt;input type=\"text\" name=\"\" id=\"inp\"&gt;&lt;span id='txt'&gt;&lt;/span&gt; 123456789101112let obj = &#123;&#125;Object.defineProperty(obj, 'txt', &#123; set(val) &#123; document.querySelector('#inp').value = val document.getElementById('txt').innerText = val &#125;&#125;)document.getElementById('inp').onkeyup = function (e) &#123; obj.txt = e.target.value&#125; 数据初始化绑定1234&lt;div id='app'&gt; &lt;input type=\"text\" v-model=\"txt\"&gt; &#123;&#123;txt&#125;&#125;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function compile(node, vm) &#123; var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/ if (node.nodeType === 1) &#123; // nodeType：element var attr = node.attributes for (var i = 0, item; item = attr[i++];) &#123; if (item.nodeName === 'v-model') &#123; var name = item.nodeValue node.value = vm.data[name] node.removeAttribute('v-model') &#125; &#125; &#125; if (node.nodeType === 3) &#123; // nodeType：文本 if (reg.test(node.nodeValue)) &#123; var name = RegExp.$1 name = name.trim() node.nodeValue = vm.data[name] &#125; &#125;&#125;function nodeToFragment(node, vm) &#123; var flag = document.createDocumentFragment() var child while (child = node.firstChild) &#123; compile(child, vm) flag.appendChild(child) &#125; return flag&#125;function Vue(options) &#123; this.data = options.data var id = options.el var dom = nodeToFragment(document.getElementById(id), this) document.getElementById(id).appendChild(dom)&#125;var vm = new Vue(&#123; el: 'app', data: &#123; txt: 'hello world' &#125;&#125;) 响应式的数据绑定1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/*** 把data中的属性设置为 vm 的访问器属性* obj:vm* key:data中的属性* val：data属性对应的属性值*/function defineReactive(obj, key, val) &#123; Object.defineProperty(obj, key, &#123; get() &#123; return val &#125;, set(newVal) &#123; if (newVal === val) return val = newVal &#125; &#125;)&#125;/*** obj:data* vm:Vue实例*/function observe(obj, vm) &#123; Object.keys(obj).forEach(item =&gt; &#123; defineReactive(vm, item, obj[item]) &#125;)&#125;function compile(node, vm) &#123; var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/ if (node.nodeType === 1) &#123; var attr = node.attributes for (var i = 0, item; item = attr[i++];) &#123; if (item.nodeName === 'v-model') &#123; var name = item.nodeValue node.addEventListener('input', e =&gt; &#123; vm[name] = e.target.value &#125;) node.value = vm[name] node.removeAttribute('v-model') &#125; &#125; &#125; if (node.nodeType === 3) &#123; if (reg.test(node.nodeValue)) &#123; var name = RegExp.$1 name = name.trim() node.nodeValue = vm[name] &#125; &#125;&#125;function nodeToFragment(node, vm) &#123; var flag = document.createDocumentFragment() var child while (child = node.firstChild) &#123; compile(child, vm) flag.appendChild(child) &#125; return flag&#125;function Vue(options) &#123; this.data = options.data observe(this.data, this) var id = options.el var dom = nodeToFragment(document.getElementById(id), this) document.getElementById(id).appendChild(dom)&#125; vm 的访问器属性发生改变时，更新视图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** 观察者模式：*/class Dep &#123; constructor() &#123; this.subs = [] &#125; addSub(sub) &#123; this.subs.push(sub) &#125; notify() &#123; this.subs.forEach(item =&gt; item.update()) &#125;&#125;var dep = new Dep()function defineReactive(obj, key, val) &#123; Object.defineProperty(obj, key, &#123; get() &#123; if (Dep.target) dep.addSub(Dep.target) return val &#125;, set(newVal) &#123; if (newVal === val) return val = newVal dep.notify() &#125; &#125;)&#125;function observe(obj, vm) &#123; Object.keys(obj).forEach(item =&gt; &#123; defineReactive(vm, item, obj[item]) &#125;)&#125;class Watcher &#123; constructor(vm, node, name) &#123; Dep.target = this this.vm = vm this.node = node this.name = name this.update() Dep.target = null &#125; update() &#123; this.node.nodeValue = this.vm[this.name] // 触发对应访问器的get方法 &#125;&#125;function compile(node, vm) &#123; var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/ if (node.nodeType === 1) &#123; var attr = node.attributes for (var i = 0, item; item = attr[i++];) &#123; if (item.nodeName === 'v-model') &#123; var name = item.nodeValue node.addEventListener('input', e =&gt; &#123; vm[name] = e.target.value &#125;) node.value = vm[name] node.removeAttribute('v-model') &#125; &#125; &#125; if (node.nodeType === 3) &#123; if (reg.test(node.nodeValue)) &#123; var name = RegExp.$1 name = name.trim() new Watcher(vm, node, name) &#125; &#125;&#125;function nodeToFragment(node, vm) &#123; var flag = document.createDocumentFragment() var child while (child = node.firstChild) &#123; compile(child, vm) flag.appendChild(child) &#125; return flag&#125;function Vue(options) &#123; this.data = options.data observe(this.data, this) var id = options.el var dom = nodeToFragment(document.getElementById(id), this) document.getElementById(id).appendChild(dom)&#125;var vm = new Vue(&#123; el: 'app', data: &#123; txt: 'hello world' &#125;&#125;)","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://capisy.github.io/tags/vue/"}]},{"title":"mongo shell 索引","slug":"mongo-shell-4","date":"2018-08-09T00:34:00.000Z","updated":"2020-03-01T14:22:53.461Z","comments":true,"path":"2018/08/09/mongo-shell-4/","link":"","permalink":"https://capisy.github.io/2018/08/09/mongo-shell-4/","excerpt":"","text":"索引就是对指定的字段进行排序的数据结构,可以加快文档查询和文档排序的速度。 复合索引只支持前缀子查询 创建索引创建单键索引1db.user.createIndex(&#123; name:1 &#125;) // 为name字段创建索引 创建复合键索引1db.user.createIndex(&#123; name:1, age:-1 &#125;) // 顺序很重要(前缀子查询) 创建多键索引1db.user.createIndex(&#123; addr:1 &#125;) // 针对数组字段建立的索引 创建唯一性索引1db.user.createIndex(&#123; name:1 &#125;,&#123; unique:true &#125;) 创建稀疏性索引（ 只将包含索引字段的文档加入到索引中 ）1db.user.createIndex(&#123; addr:1 &#125;,&#123; sparse:true &#125;) 查看当前collection的索引1db.user.getIndexes() explain,查看数据库查询过程1db.user.explain().find(&#123; name:1 &#125;) 删除索引1db.user.dropIndex(&#123; name:1 &#125;) 索引的生存时间(删除document) 针对日期字段，或者包含日期元素的数组字段，可以使用设定了生存时间的索引来自动删除字段值超过生存时间的文档 1db.user.insert(&#123; name:'sy', lastAccess:new Date() &#125;) // 这里用时间戳是无效的 1db.user.createIndex(&#123; lastAccess:1 &#125;,&#123; expireAfterSeconds:20 &#125;)","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://capisy.github.io/tags/mongodb/"}]},{"title":"mongo shell 聚合管道","slug":"mongo-shell-3","date":"2018-08-08T01:55:00.000Z","updated":"2020-03-01T14:22:53.460Z","comments":true,"path":"2018/08/08/mongo-shell-3/","link":"","permalink":"https://capisy.github.io/2018/08/08/mongo-shell-3/","excerpt":"","text":"1db.user.insert(&#123;name:'sy',age:16,addr:&#123;country:'Japan',city:'Tokyo'&#125;&#125;) $project:对查找到的结果重新映射（类似于mysql的视图）123db.user.aggregate([ &#123;$project:&#123;_id:0,username:\"$name\"&#125;&#125;]) 123db.user.aggregate([ &#123;$project:&#123;_id:0,name:1,city:\"$addr.city\"&#125;&#125;]) $match：匹配1234db.user.aggregate([ &#123;$match:&#123;\"addr.city\":\"Tokyo\"&#125;&#125;, &#123;$project:&#123;_id:0&#125;&#125;]) 12345678db.user.aggregate([ &#123;$match:&#123; $or:[ &#123;\"addr.city\":'Tokyo'&#125;, &#123; age:&#123;$lt:24&#125; &#125; ] &#125;&#125;]) // 地址是东京或者年龄小于24 $limit 和 $skip123db.user.aggregate([ &#123;$limit:1&#125;]) 123db.user.aggregate([ &#123;$skip: 2&#125;]) $unwind：数组字段展开1db.user.insert(&#123;name:'ycy',addr:['JS','SZ']&#125;) 12345678db.user.aggregate([ &#123;$unwind:&#123; path:\"$addr\" &#125;&#125;, &#123;$project:&#123;_id:0&#125;&#125;]) // 把数组字段按值分离成多条数据// &#123;name:'ycy',adddr:'JS'&#125;// &#123;name:'ycy',adddr:'SZ'&#125; 123456789db.user.aggregate([ &#123;$unwind:&#123; path:\"$addr\", includeArrayIndex:'cityIdx' // 新生成的字段在原数组中的索引 &#125;&#125;, &#123;$project:&#123;_id:0&#125;&#125;])// &#123;name:'ycy',adddr:'JS',cityIdx:NumberLong(0)&#125;// &#123;name:'ycy',adddr:'SZ',cityIdx:NumberLong(1)&#125; $sort：排序123db.user.aggregate([ &#123;$sort:&#123;age:1, name：-1&#125;&#125;]) $lookup: 类似于连表查询1234db.user.inert([ &#123;name:'ycy',cid:0&#125; &#123;name:'sy',cid:1&#125;]) 1234db.country.insert([ &#123;cname:'China',cid:0&#125;, &#123;cname:'Japan',cid:1&#125;]) 12345678910db.user.aggregate([ $lookup:&#123; from:'country', localField:'cid', // user-&gt;cid foreignField:'cid', // country-&gt;cid as:'country_info' &#125;])// &#123;name:'ycy', cid:0, country_info:&#123;cname:'China', cid:0 &#125; &#125;// &#123;name:'sy', cid:1, country_info:&#123;cname:'Japan', cid:1 &#125; &#125; $group:分组123456db.goods.insert([ &#123;gtyp:'pc',price:5555,amount:10&#125;, &#123;gtyp:'pc',price:12555,amount:8&#125;, &#123;gtyp:'phone',price:3555,amount:12&#125;, &#123;gtyp:'phone',price:2999,amount:11&#125;,]) 123db.goods.aggregate([ &#123; $group:&#123; _id:'$gtyp' &#125; &#125;]) // [ &#123;'_id':'phone'&#125;,&#123;'_id':'pc'&#125; ] 1234567891011db.goods.aggregate([ &#123;$group:&#123; _id:'$gtyp', amounts:&#123; $sum:'$amount'&#125;, totalPrice:&#123; $sum:&#123; $multiply:['$price','$amount'] &#125; &#125;, avgPrice:&#123; $avg:'$price' &#125;, count: &#123; $sum:1&#125;, // 分组中的数据条数 maxPrice: &#123; $max:'$price'&#125;, minTotalPrice:&#123; $min:&#123;$multiply:['$price','$amount']&#125; &#125; &#125;&#125;]) 123456db.goods.aggregate([ &#123;$group:&#123; _id:null, amounts:&#123; $sum:'$amount'&#125;, &#125;&#125;]) // 不分组，但可以使用计算功能 $out: 把聚合管道的输出结果写入新的collection1234db.goods.aggregate([ &#123; $group:&#123; _id:'$gtyp' &#125; &#125;, &#123; $out:'output' &#125;]) 1db.output.find() allowDiskuse, 在数据量超过100M时，使用磁盘存储12345db.goods.aggregate([],&#123; allowDiskUse:true // 默认为false&#125;)","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://capisy.github.io/tags/mongodb/"}]},{"title":"mongo shell 更新操作","slug":"mongo-shell-2","date":"2018-08-07T06:14:00.000Z","updated":"2020-03-01T14:22:53.460Z","comments":true,"path":"2018/08/07/mongo-shell-2/","link":"","permalink":"https://capisy.github.io/2018/08/07/mongo-shell-2/","excerpt":"","text":"update 方法 只能更新查询结果集中的第一条数据 1db.user.update(&#123;name:'sy'&#125;,&#123;name:'sy',age:16&#125;) // @p1:查询条件 @p2:更新后的文档 $set 操作符1234db.user.update(&#123;name:'sy'&#125;,&#123;$set:&#123; age:17, addr:['Japan','Tokyo']&#125;&#125;) // 更新age字段，添加addr字段 123db.user.update(&#123;name:'sy'&#125;,&#123;$set:&#123; 'addr.1':'东京'&#125;&#125;) // 如果文档的参数为对象或数组的时候用'.'操作符选取 $unset 操作符1234db.user.update(&#123;name:'sy'&#125;,&#123;$unset:&#123; age:0 'addr.1':0&#125;&#125;) // &#123;name:'sy',addr:['Japan',null]&#125; $rename 操作符 $rename中的旧字段和新字段都不可以指向数组元素 123db.user.update(&#123;name:'sy'&#125;,&#123;$rename:&#123; addr:'location'&#125;&#125;) // &#123;name:'sy',location:['Japan',null]&#125; 123db.user.update(&#123;name:'sy'&#125;,&#123;$rename:&#123; location:'info.location'&#125;&#125;) // &#123;name:'sy',info:&#123; location:['Japan',null] &#125; &#125; $inc（increment） 操作符123db.user.update(&#123;&#125;,&#123;$inc:&#123; age:-1&#125;&#125;) // 年龄字段的值减一 $mul （multiplication:乘法）操作符123db.user.update(&#123;&#125;,&#123;$mul:&#123; balance: 0.5&#125;&#125;) // 余额字段除以2 $min 和 $max 操作符123db.user.update(&#123;&#125;,&#123;$min:&#123; balance: 1000&#125;&#125;) // 如果更新后的值比原值小则更新，反之不更新 123db.user.update(&#123;&#125;,&#123;$max:&#123; balance: 1000&#125;&#125;) // 如果更新后的值比原值大则更新，反之不更新 如果被更新的字段不存在，$min 和 $max 会创建改字段，并把值设为更新的值 与更新数组字段有关的操作符$addToSet : 向数组字段添加新值123db.user.update(&#123;&#125;,&#123;$addToSet:&#123; location:'ToKyo'&#125;&#125;) // 如果数组中没有相同的val则更新数组，反之不更新 $each：一次向数组字段添加多个新值12345db.user.update(&#123;&#125;,&#123;$addToSet:&#123; occupation:&#123; $each:['actress','idol'] &#125;&#125;&#125;) // &#123;...,occupation:['actress','idol']&#125; $pop：从数组字段中删除元素123db.user.update(&#123;&#125;,&#123;$pop:&#123; location:1&#125;&#125;) // 1:从数组最后删除一个元素，-1：从数组最前删除一个元素 $pull：从数组字段中删除特定的元素12345db.user.update(&#123;&#125;,&#123;$pull:&#123; addr:&#123; $regex:/^ja/i &#125;&#125;&#125;) // &#123;... addr:['ToKyo']&#125; $ ：query中匹配的元素123db.user.update(&#123;addr:'ToKyo'&#125;,&#123;$set:&#123; 'addr.$':'东京'&#125;&#125;) // &#123;...,addr:['东京']&#125; 一次更新所有查询匹配的数据 @p3:如果查询的匹配结果为空，是否插入新的文档，默认为false @p4:默认为false：只更新找到的第一条数据，true:更新所有找到的数据 1db.user.update(&#123;name:'sy'&#125;,&#123;$set:&#123;age:16&#125;&#125;,false,true); collection 重命名1db.user.renameCollection('users'); // user -&gt; users","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://capisy.github.io/tags/mongodb/"}]},{"title":"mongo shell 增加、删除、查询操作","slug":"mongo-shell-1","date":"2018-08-06T01:55:00.000Z","updated":"2020-03-01T14:22:53.459Z","comments":true,"path":"2018/08/06/mongo-shell-1/","link":"","permalink":"https://capisy.github.io/2018/08/06/mongo-shell-1/","excerpt":"","text":"开启mongo shell 配置path cmd -&gt; mongo mongo shell 操作新建数据库1use mf_egg 显示数据库列表1show dbs // 这里没有显示mf_egg,因为新建的数据库是空的 添加一条数据1db.user.insertOne(&#123;name:'shiyuan'&#125;) // 新建一个名为user的集合，并插入一条数据 12show dbs // 显示mf_egg 数据库show collections // user 删除一条数据1db.user.remove(&#123;name:'shiyuan'&#125;) 删除一个集合1db.user.drop() // 如果一个数据库中没有集合存在，数据库会被自动删除 删除文档1db.user.remove(&#123;&#125;); // 删除所有文档，但会保留集合 1db.user.remove(&#123;name:'sy'&#125;); // 删除所有符合筛选条件的文档 1db.user.remove(&#123;name:'sy'&#125;,&#123;justOne:true&#125;) // 删除符合条件的最先匹配的一篇文档 一次添加多条数据1db.user.insertMany([&#123;name:'十元'&#125;，&#123;name:'sy'&#125;]) 使用insert插入数据（insert = insertOne + insertMany）1db.user.insert(&#123;name:'石原里美',contact:['Japan','Tokyo']&#125;) 查询单条数据1db.user.findOne(&#123;name:'石原里美'&#125;) 使用$all修饰符查询1db.user.findOne(&#123;contact:&#123;$all:['Japan','Tokyo']&#125;&#125;) 使用$gt(大于)，$lt(小于)修饰符查询12db.user.insertOne(&#123;name:'sy',age:16&#125;)db.user.findOne(&#123;age:&#123;$gt:10,$lt:20&#125;&#125;) // 查询年龄在10-20岁之内的数据 使用$elemMatch修饰符查询 $elemMatch的匹配条件必须是一个Object 文档中只要有一个元素满足查询条件即可 123456db.user.insertOne(&#123;name:'sy',tel:[1550000]&#125;)db.user.insertOne(&#123;name:'shiyuan',tel:[155，1550000]&#125;)// 查询tel&gt;1000000的数据// 上面的两条数据都可以被查询到db.user.findOne(&#123;tel:&#123;$elemMatch:&#123;$gt:1000000&#125;&#125;&#125;) $all和$elemMatch 配合使用12345678910111213db.user.insertOne(&#123;name:'sy',tel:[1550000,5550000]&#125;)// 查询电话号码同时在1000000-2000000和5000000-6000000的数据db.user.findOne( &#123; tel:&#123; $all:[ &#123; $elemMatch:&#123;$gt:1000000,$lt:2000000&#125; &#125; &#123; $elemMatch:&#123;$gt:5000000,$lt:6000000&#125; &#125; ] &#125; &#125;) 正则表达式修饰符1db.user.find(&#123;name:/^s/&#125;) // 查找name以's'开头的数据 $pattern + $all1db.user.find(&#123; name:&#123;$all:[/^s/,/y$/]&#125; &#125;) // 查找name以's'开头且以'y'结尾的数据 $pattern + $in1db.user.find(&#123; name:&#123;$in:[/^s/,/y$/]&#125; &#125;) // 查找name以's'开头或以'y'结尾的数据 skip 和 limit 方法1db.user.find(&#123;name:'sy'&#125;).limit(5) // 从结果集中取前5条数据 1db.user.find(&#123;name:'sy'&#125;).skip(2) // 返回结果集中前两条数据之外的数据 1db.user.find(&#123;name:'sy'&#125;).skip(2).limit(5) // 从结果集的第三天数据开始，选取之后的5条数据 count 方法：返回结果集的length1db.user.find(&#123;name:'sy'&#125;).count() // 假设结果集中有6条数据 1db.user.find(&#123;name:'sy'&#125;).limit(1).count() // 6 1db.user.find(&#123;name:'sy'&#125;).limit(1).count(true) // 1 1db.user.find(&#123;name:'sy'&#125;).skip(1).count(true) // 5 sort 方法（排序）1db.user.find().sort(&#123;name:1&#125;) // 按照name递增排序 1db.user.find().sort(&#123;name:1,age:-1&#125;) // name递增，age递减排序 sort + limit：查询最xx的一条数据1db.user.find().sort(&#123;age:-1&#125;).limit(1) // 查询年龄最大的一条数据 sort, skip, limit 的执行顺序1db.user.find().sort().skip().limit() 查询指定的字段 除了主键文档外，不可以在投影文档中混用包含和不包含操作 1db.user.find(&#123;&#125;,&#123;name:1,_id:0&#125;) // 只查询 name 字段 1db.user.find(&#123;&#125;,&#123;age:0&#125;) // 查询除了 age 之外的所有字段 $slice 操作符返回数组字段中的部分元素1db.user.find(&#123;&#125;,&#123;contact:&#123; $slice:1 &#125;&#125;) // $slice的取值为返回数组的前几项 1db.user.find(&#123;&#125;,&#123;contact:&#123; $slice:-1 &#125;&#125;) // 返回数组的后几项 1db.user.find(&#123;&#125;,&#123;contact:&#123; $slice:[1,2] &#125;&#125;) // 类似 skip(1),limit(2) 操作 $elemMatch 操作符可以返回数组字段中满足筛选条件的第一个元素1db.user.insert(&#123;name:'sy',location:['Japan','Tokyo','xxx']&#125;) 1234567db.user.find(&#123;&#125;,&#123; _id:0, name:1, location:&#123; $elemMatch:&#123; $gt:'Japan' &#125; &#125;&#125;) // &#123;name:'sy',location:['Tokyo']&#125;","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://capisy.github.io/tags/mongodb/"}]},{"title":"vue中指令的用法","slug":"vue-directive","date":"2018-05-05T11:07:00.000Z","updated":"2020-03-01T14:22:53.466Z","comments":true,"path":"2018/05/05/vue-directive/","link":"","permalink":"https://capisy.github.io/2018/05/05/vue-directive/","excerpt":"","text":"","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://capisy.github.io/tags/vue/"}]},{"title":"备忘Git不常用的命令","slug":"git","date":"2018-02-09T01:07:00.000Z","updated":"2020-03-01T14:22:53.457Z","comments":true,"path":"2018/02/09/git/","link":"","permalink":"https://capisy.github.io/2018/02/09/git/","excerpt":"","text":"生成 ssh1ssh-keygen -t rsa -C \"925697@163.com\" warning: LF will be replaced by CRLF1git config --global core.autocrlf false 日志统计12git log --graph // 打印提交信息git log --stat // 打印提交统计 比较提交123git diff //查看修改的文件的内容git diff --stat // 功能同上，显示更友好git diff --cached //查看缓存区内和上次提交的内容的差别 新建一个空分支1git checkout --orphan &lt;new branch&gt; 克隆 github 上项目的非 master 分支12git branch -agit checkout -b &lt;name&gt; origin/&lt;name&gt;","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://capisy.github.io/tags/git/"}]},{"title":"vue-router","slug":"vue-router","date":"2018-01-31T08:07:00.000Z","updated":"2020-03-01T14:22:53.467Z","comments":true,"path":"2018/01/31/vue-router/","link":"","permalink":"https://capisy.github.io/2018/01/31/vue-router/","excerpt":"","text":"初始化1234567891011121314new Router(&#123; routes, // 路由配置 mode: \"history\", fallback:true, linkExactActiveClass: \"exact-active\", linkActiveClass: \"active\", scrollBehavior(to,from,savedPosition)&#123; if(savedPosition)&#123; return savedPosition &#125;else &#123; return &#123;x:0,y:0&#125; &#125; &#125;&#125;) 路由配置123456789101112131415161718192021222324252627const routes = [ &#123; path:'/', redirect:'/home' &#125;, &#123; path:'/home', component: HomeCmp, name:'home', meta:&#123; title:'首页', description:'这是首页' &#125;, children:[ &#123; path:'test', component:TestCmp, name:'test', &#125; ] &#125;]&lt;router-link to=\"/home\"&gt;home&lt;/router-link&gt;&lt;router-link :to=\"&#123;name:'home'&#125;\"&gt;home&lt;/router-link&gt;&lt;router-view&gt;&lt;/router-view&gt; 12345678910// 路由过渡动画.fade-enter-active,.fade-leave-active&#123; transition:opacity 0.5s;&#125;.fade-enter,.fade-leave-to&#123; opacity:0&#125;&lt;transition name=\"fade\"&gt; &lt;router-view /&gt;&lt;/transition&gt; 路由传参12345678910111213141516171819[ &#123; path:'/app/:id', component:AppCmp, name:'app' &#125;, &#123; path:'/app2/:id2', component:App2Cmp, name:'app2', props:true, &#125;]let _id = this.$route.params.id // 获取参数// 注册propsprops:['id2']// 获取idlet _id2 = this.props.id2","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://capisy.github.io/tags/vue/"}]},{"title":"权限管理","slug":"Linux-chmod","date":"2018-01-31T02:07:00.000Z","updated":"2020-03-01T14:22:53.456Z","comments":true,"path":"2018/01/31/Linux-chmod/","link":"","permalink":"https://capisy.github.io/2018/01/31/Linux-chmod/","excerpt":"","text":"查看文件权限1ls -l 文件权限 读权限，表示你可以使用 cat 之类的命令来读取某个文件的内容； 写权限，表示你可以编辑和修改某个文件； 执行权限，通常指可以运行的二进制程序文件或者脚本文件，如同 Windows 上的 exe 后缀的文件，不过 Linux 上不是通过文件后缀名来区分文件的类型。 一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息。 修改文件权限12chmod 777 &lt;file&gt; //rwx 最高权限chmod go-rw &lt;file&gt; //g: group,o:others,u:user&gt;; +:增加权限，-： 去掉权限 防火墙操作查看防火墙状态 12firewall-cmd --statesystemctl status firewalld 关闭、开启防火墙 12systemctl start firewalldsystemctl stop firewalld 禁止 firewall 开机启动 1systemctl disable firewalld 查看已经开放的端口 1firewall-cmd --list-ports 开启端口 12345firewall-cmd --zone=public --add-port=80/tcp --permanent命令含义:–zone #作用域–add-port=80/tcp #添加端口，格式为：端口/通讯协议–permanent #永久生效，没有此参数重启后失效 关闭端口 1firewall-cmd --add-port=80/tcp --permanent 重载生效刚才的端口设置 1firewall-cmd --reload","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://capisy.github.io/tags/Linux/"}]},{"title":"用户管理","slug":"Linux-user","date":"2018-01-30T02:07:00.000Z","updated":"2020-03-01T14:22:53.457Z","comments":true,"path":"2018/01/30/Linux-user/","link":"","permalink":"https://capisy.github.io/2018/01/30/Linux-user/","excerpt":"","text":"查看用户12who am i //输出用户名，终端序号，终端启动时间whoami //输出用户名 创建用户一般登录系统的时候都是以普通用户的身份登录的，要创建用户需要 root 权限。这里就要用到 sodu（switch user do）,使用 sudo 命名的两个前提条件 知道当前登录用户的密码 当前用户必须在 sudo 用户组 12su &lt;user&gt; //切换到用户usersudo &lt;cmd&gt; //可以以特权级别运行cmd命令，需要当前用户属于sudo组，且需要输入当前账户的密码 1sudo adduser yyy //新建一个叫yyy的新用户，同时为新用户创建home目录 用户组 groups1groups yyy // yyy:yyy 冒号之前表示用户，后面表示该用户所属的用户组。每次新建用户如果不指定用户组的话，会默认自动创建一个与用户名相同的用户组。 将其他用户加入 sudo 用户组默认情况下新创建的用户是不具有 root 权限的，也不在 sudo 用户组中，可以让其加入 sudo 用户组从而获取 root 权限 普通用户赋予 root 权限修改 /etc/sudoers 文件或 visudo 直接打开，找到下面一行，在 root 下面添加一行，如下所示： 123## Allow root to run any commands anywhereroot ALL=(ALL) ALLMF ALL=(ALL) ALL 修改完毕，现在可以用 tommy 帐号登录，然后用命令 su - ，即可获得 root 权限进行操作。 使用 usermod 命令可以为用户添加用户组，使用该命令必须有 root 权限。可以使用 root 用户为其他用户添加用户组，或者在其他已经在 sudo 用户组的用户使用 sudo 命令获取权限来执行该命令 123su MFsudo usermod -G sudo yyygroups yyy usermod 命令用于修改用户的基本信息。usermod 命令不允许你改变正在线上的使用者帐号名称。当 usermod 命令用来改变 user id，必须确认这名 user 没在电脑上执行任何程序。你需手动更改使用者的 crontab 档。也需手动更改使用者的 at 工作档。采用 NIS server 须在 server 上更动相关的 NIS 设定。 c&lt;备注&gt;：修改用户帐号的备注文字； d&lt;登入目录&gt;：修改用户登入时的目录； e&lt;有效期限&gt;：修改帐号的有效期限； f&lt;缓冲天数&gt;：修改在密码过期后多少天即关闭该帐号； g&lt;群组&gt;：修改用户所属的群组； G&lt;群组&gt;；修改用户所属的附加群组； l&lt;帐号名称&gt;：修改用户帐号名称； L：锁定用户密码，使密码无效； s：修改用户登入后所使用的 shell； u：修改用户 ID； U:解除密码锁定。 删除用户1sudo deluser yyy --remove-home","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://capisy.github.io/tags/Linux/"}]},{"title":"虚拟内存&kxsw","slug":"linux-swap","date":"2018-01-30T02:07:00.000Z","updated":"2020-03-01T14:22:53.459Z","comments":true,"path":"2018/01/30/linux-swap/","link":"","permalink":"https://capisy.github.io/2018/01/30/linux-swap/","excerpt":"","text":"查看磁盘空间1df -hl // 查看磁盘使用情况 12du -sh &lt;文件夹名&gt; // 查看文件夹大小du -sh * // 查看当前文件夹内所有文件大小 查看内存使用情况1free -hl 内存不够用，设置 swap1234567891011mkdir -p /opt/tempdd if=/dev/zero of=/opt/temp/swap bs=1024 count=2048000mkswap -f /opt/temp/swapswapon /opt/temp/swapecho &quot;/opt/temp/swap swap swap defaults 0 0&quot; &gt;&gt;/etc/fstabreboot kxsw1yum -y install wget 安装 1234567cd /usr/local/srcwget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 配置 12345678910&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:9906, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;heheda~&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;:false&#125; 扩展 123456启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart状态：/etc/init.d/shadowsocks status配置文件路径：/etc/shadowsocks.json卸载方法：/usr/local/src/shadowsocks.sh uninstall bbr（可选，提升不大） 12345wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://capisy.github.io/tags/Linux/"}]},{"title":"TS小记","slug":"typescript","date":"2018-01-21T00:23:12.000Z","updated":"2020-03-01T14:22:53.465Z","comments":true,"path":"2018/01/21/typescript/","link":"","permalink":"https://capisy.github.io/2018/01/21/typescript/","excerpt":"","text":"数组的两种声明方式123const list1:number[] = [1,2,3]const list2:Array&lt;string&gt; = ['mf'] // 泛型数组 二维数组1234const list3:number[][] = [ [1,2,3], [4,5,6]] 元组类型 元组和数组类似，只不过元组是一种固定长度的数组，每个元素有自己的类型。 1const x:[string,number] = ['yjy',16] 接口声明和实例化12345678910111213interface IPerson &#123; name: string, age: number, loving: string[], sex?: 'male' | 'famale'&#125;const mf: IPerson = &#123; name: 'mf', age: 27, loving: ['zcj', 'yjy'], sex: 'male'&#125; 接口允许有任意属性一旦定义了任意属性，那么确定属性和可选属性的类型必须是它类型的子集 123interface IPerson&#123; [propName:string]:any&#125; 接口的只读属性定义123interface IPerson&#123; readonly name:string&#125; 函数的定义普通函数1const func = (a:number,b:string):string =&gt; a+b 可选参数123const func2 = (a: string, b?: string): string =&gt; &#123; return b ? `$&#123;a&#125; $&#123;b&#125;` : a&#125; 参数的默认值1const func4 = (a:string,b:string='yjy') =&gt; `$&#123;a&#125; $&#123;b&#125;` 用接口定义函数12345interface IFunc &#123; (a: string, b: string): string&#125;const func3: IFunc = (a, b) =&gt; a + b 泛型 解决类、接口、函数的复用性，以及对不特定数据类型的支持 说人话，数据的类型跟根据调用时的数据类型决定的，表示的参数是什么就返回什么类型 泛型定义函数123456function getValue&lt;T&gt;(value:T):T&#123; return value&#125;getValue&lt;string&gt;('yjy')getValue&lt;boolean&gt;(true) 泛型定义接口的两种方式123456interface IFunc&#123; &lt;T&gt;(value:T):T&#125;const getVal2:IFunc = val =&gt; valgetValue&lt;string&gt;('yjy') 123456interface IFunc2&lt;T&gt;&#123; (value:T):T&#125;const getVal3:IFunc&lt;string&gt; = val =&gt; valgetVal3('yjy') 泛型定义类12345678910111213141516class Identity&lt;T1, T2&gt;&#123; public p1: T1 // public可省略 private p2: T2 constructor(p1: T1, p2: T2) &#123; this.p1 = p1 this.p2 = p2 &#125; getP1(): T1 &#123; return this.p1 &#125; showP2(): void &#123; console.log(this.p2) &#125;&#125;let mf = new Identity&lt;string, number&gt;('yjy', 16) 泛型约束问题: 不能确定T是否具有length属性，会报错 1const getLength = &lt;T&gt;(arg: T): number =&gt; arg.length 解决方法: 12345interface IWithLenght&#123; length:number&#125;const getLength = &lt;T extends IWithLenght&gt;(arg: T): number =&gt; arg.length 泛型约束设置默认类型问题：如果大多数情况下T的类型都为string，每次都要声明会很麻烦 1234567interface IMyTyp&lt;T&gt;&#123; value:T&#125;let a:IMyTyp&lt;string&gt;&#123; value:'hello world'&#125; 解决： 1234567891011interface IMyTyp2&lt;T=string&gt;&#123; value:T&#125;let b:IMyTyp2=&#123; value:'hello !'&#125;let c:IMyTyp2&lt;number&gt;=&#123; value:123&#125; 命名空间语法 命名空间引入了新的作用域，大括号可以包含任意合法的代码 要在命名空间之外访问命名空间内的成员，必须使用export关键字 1234567namespace ns&#123; export const a:string = 'hello world' const b:string = 'hi world'&#125;const c:string = ns.a // √const d:string = ns.b // × 实现原理：立即执行函数 12345var ns;(function (ns) &#123; ns.a = 'hello world'; var b = 'hi ts';&#125;)(ns || (ns = &#123;&#125;)); 空间拆分 命名空间可以拆分，代码量大时可以提高可维护性 拆分的代码块之间的成员无法互相访问 访问需要export 导出 1234567891011namespace ns&#123; const a:number export function showA():void&#123; console.log(a) &#125;&#125;namespace ns&#123; const b:number = a + 1 // × showA() // √&#125; 空间嵌套 作用域为{}，作用域外不可访问 12345678namespace ns &#123; namespace subNs&#123; const a:string = 'yjy' export const b:string = 'yjy' &#125; const c:string = subNs.a // × const d:string = subNs.b // √&#125; 访问嵌套空间内的属性，嵌套空间也需要export 1234567namespace ns &#123; export namespace subNs&#123; export const e:string = 'yjy' &#125;&#125;const f:string = ns.subNs.e 类类型类类型中可以把实例属性和静态属性直接定义在类内部1234567// es6class Foo&#123; constructor()&#123; this.test = 'hi' &#125;&#125;Foo.test1 = 'world' 123456789101112131415// ts// 推荐写法class Foo&#123; test:string = 'hi' // test属性必须先声明再使用 constructor(test:string)&#123; this.test = test &#125;&#125;// 另外一种写法class Foo&#123; constructor(public test:string)&#123; this.test = test &#125;&#125; 12345// ts// 静态属性：只能由构造器调用的属性class Foo&#123; static test1:string = 'world'&#125; 抽象类和抽象方法 抽象类和抽象方法都由关键字abstract声明 抽象方法没有函数体，由继承的子类(派生类)实现 一个类包含抽象方法，这个类必须是抽象类 抽象类可以没有抽象方法 123456789abstract class Father&#123; abstract showMsg(name:string):string&#125;class Son extends Father&#123; showMsg(name:string)&#123; return `My name is $&#123;name&#125;` &#125;&#125;","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://capisy.github.io/tags/typescript/"}]},{"title":"表单验证","slug":"helper-validate","date":"2017-12-29T16:00:00.000Z","updated":"2020-03-01T14:22:53.458Z","comments":true,"path":"2017/12/30/helper-validate/","link":"","permalink":"https://capisy.github.io/2017/12/30/helper-validate/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class ValidateBase &#123; constructor(rules) &#123; this.errMsg = '' this.rules = rules this.ruleIdx = 0 &#125; init() &#123; return this.parseRules().isValidate() &#125; parseRules() &#123; if (!this.rules.length) return this for (const rule of this.rules) &#123; const err = this.createErrMsg(rule) if (!err) break &#125; return this &#125; createErrMsg(rule) &#123; this.ruleIdx++ const ruleTyp = typeof rule['_v'] if (ruleTyp !== 'string') &#123; this.errMsg = `R$&#123;this.ruleIdx&#125;: Typeof _v is $&#123;ruleTyp&#125;, not string` return false &#125; let flag = true const vItems = Object.keys(rule).slice(1) for (const vItem of vItems) &#123; const transName = ($, $1, $2) =&gt; `is$&#123;$1.toUpperCase()&#125;$&#123;$2&#125;` const fnName = vItem.replace(/(\\w)(.*)/, transName) let _flag = this[fnName](rule) if (_flag === false) &#123; flag = false break &#125; &#125; return flag &#125; isValidate() &#123; return this.errMsg ? &#123; msg: this.errMsg &#125; : false &#125;&#125;class Validate extends ValidateBase &#123; isRequired() &#123; // 判断传入的值是否为空 const &#123; _v, required &#125; = arguments[0] if (required[0] &amp;&amp; _v.trim() === '') &#123; this.errMsg = required[1] return false &#125; &#125; isRegExp() &#123; // 判断是否通过正则校验 const &#123; _v, regExp &#125; = arguments[0] if (!regExp[0].test(_v)) &#123; this.errMsg = regExp[1] return false &#125; &#125; isPswAgain() &#123; // 判断两次输入的密码是否相同 const &#123; _v, pswAgain &#125; = arguments[0] if (pswAgain[0] !== _v) &#123; this.errMsg = pswAgain[1] return false &#125; &#125;&#125;export default function(rules) &#123; return new Validate(rules).init()&#125; 1234567891011121314151617181920// 调用const errMsg = validate([ &#123; _v: this.msg, required: [true, '不为空'], regExp: [/^\\w&#123;2,5&#125;$/i, '密码为2-5位'], &#125;, &#123; _v: this.msg2, required: [true, '再次输入密码为空'], pswAgain: [this.msg, '两次输入的密码不同'], &#125;,])if(errMsg)&#123; // 处理错误信息 return&#125;// 无错误，继续执行...","categories":[],"tags":[{"name":"JS_HELPER","slug":"JS-HELPER","permalink":"https://capisy.github.io/tags/JS-HELPER/"}]},{"title":"拖拽(原型版本)","slug":"helper-drag-prototype","date":"2017-12-29T16:00:00.000Z","updated":"2020-03-01T14:22:53.458Z","comments":true,"path":"2017/12/30/helper-drag-prototype/","link":"","permalink":"https://capisy.github.io/2017/12/30/helper-drag-prototype/","excerpt":"","text":"123456789const inherit = (function() &#123; var F = function() &#123;&#125; return function(Target, Origin) &#123; F.prototype = Origin.prototype Target.prototype = new F() Target.prototype.constructor = Target Target.prototype.uber = Origin.prototype &#125;&#125;)() 1234567891011121314151617181920212223242526272829303132333435363738394041function Drag(el) &#123; this.$el = el this.clientX = 0 this.clientY = 0&#125;Drag.prototype.init = function() &#123; this.$el.onmousedown = this.mouseDown.bind(this)&#125;Drag.prototype.mouseDown = function(ev) &#123; const left = this.$el.offsetLeft const top = this.$el.offsetTop this.$el.style.zIndex = 999 this.$el.style.cursor = 'move' this.clientX = ev.clientX - left this.clientY = ev.clientY - top document.onmousemove = this.mouseMove.bind(this) document.onmouseup = this.mouseUp.bind(this)&#125;Drag.prototype.mouseMove = function(ev) &#123; const x = ev.clientX - this.clientX const y = ev.clientY - this.clientY this.$el.style.left = x + 'px' this.$el.style.top = y + 'px' return false&#125;Drag.prototype.mouseUp = function() &#123; this.$el.style.zIndex = 0 this.$el.style.cursor = 'default' document.onmousemove = null document.onmouseup = null&#125; 12345678910111213141516171819202122232425function LimitDrag(el, limit) &#123; Drag.call(this, el) limit = limit || &#123;&#125; this.minX = limit.minX || 0 this.minY = limit.minY || 0 this.maxX = limit.maxX || document.documentElement.clientWidth - this.$el.offsetWidth this.maxY = limit.maxY || document.documentElement.clientHeight - this.$el.offsetHeight&#125;inherit(LimitDrag, Drag)LimitDrag.prototype.mouseMove = function(ev) &#123; let x = ev.clientX - this.clientX let y = ev.clientY - this.clientY x = Math.max(x, this.minX) x = Math.min(x, this.maxX) y = Math.max(y, this.minY) y = Math.min(y, this.maxY) this.$el.style.left = x + 'px' this.$el.style.top = y + 'px' return false&#125;","categories":[],"tags":[{"name":"JS_HELPER","slug":"JS-HELPER","permalink":"https://capisy.github.io/tags/JS-HELPER/"}]},{"title":"拖拽(class版本)","slug":"helper-drag-class","date":"2017-12-29T16:00:00.000Z","updated":"2020-03-01T14:22:53.457Z","comments":true,"path":"2017/12/30/helper-drag-class/","link":"","permalink":"https://capisy.github.io/2017/12/30/helper-drag-class/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243class Drag &#123; constructor(el) &#123; this.$el = el this.clientX = 0 this.clientY = 0 &#125; init() &#123; this.$el.onmousedown = this.mouseDown.bind(this) &#125; mouseDown(ev) &#123; const left = this.$el.offsetLeft const top = this.$el.offsetTop this.$el.style.zIndex = 999 this.$el.style.cursor = 'move' this.clientX = ev.clientX - left this.clientY = ev.clientY - top document.onmousemove = this.mouseMove.bind(this) document.onmouseup = this.mouseUp.bind(this) &#125; mouseMove(ev) &#123; const x = ev.clientX - this.clientX const y = ev.clientY - this.clientY this.$el.style.left = x + 'px' this.$el.style.top = y + 'px' return false &#125; mouseUp() &#123; this.$el.style.zIndex = 0 this.$el.style.cursor = 'default' document.onmousemove = null document.onmouseup = null &#125;&#125; 123456789101112131415161718192021222324class LimitDrag extends Drag &#123; constructor(el, limit = &#123;&#125;) &#123; super(el) this.minX = limit.minX || 0 this.minY = limit.minY || 0 this.maxX = limit.maxX || document.documentElement.clientWidth - this.$el.offsetWidth this.maxY = limit.maxY || document.documentElement.clientHeight - this.$el.offsetHeight &#125; mouseMove(ev) &#123; let x = ev.clientX - this.clientX let y = ev.clientY - this.clientY x = Math.max(x, this.minX) x = Math.min(x, this.maxX) y = Math.max(y, this.minY) y = Math.min(y, this.maxY) this.$el.style.left = x + 'px' this.$el.style.top = y + 'px' return false &#125;&#125; 1export &#123; Drag, LimitDrag &#125;","categories":[],"tags":[{"name":"JS_HELPER","slug":"JS-HELPER","permalink":"https://capisy.github.io/tags/JS-HELPER/"}]},{"title":"漫过四月天","slug":"memory-20130510","date":"2013-05-10T01:01:02.000Z","updated":"2020-03-01T14:22:53.459Z","comments":true,"path":"2013/05/10/memory-20130510/","link":"","permalink":"https://capisy.github.io/2013/05/10/memory-20130510/","excerpt":"","text":"天空似乎比心情还要善变，雨丝在阳光的缝隙偷偷溜出显得很有线条感不经意一瞥，已经五月十号了。时光从指间划过，带走点点余温日子还是平淡到无味，麻木了太久， 就不会大喜大悲 有时候总是会强迫自己更理性一点，天性使然，不喜欢过得太复杂时常还是会一意孤行，疏忽了别人，为难了自己太自我是会伤害到别人的，而最终更受伤的会是自己唯美的意境源自不确定的朦胧，那些不真实的真实珍藏就好 中午的时候，看见三教前面的法国梧桐。我说很好看，裴说，他也很喜欢。那个北方城市里，最后和你走在一起的记忆，宛如陌生人没有激情，也不会尴尬。似乎一切都是空的，似乎一切都已无关成排法国梧桐呆板地见证着黯淡的时光，磨灭的情感 我想此时此刻的文字应该是平淡的，不参杂丝毫的心酸这一刻，你在你的梧桐树下播种你的故事，我在我香樟的世界演绎我的曲调从开始，就只是在平行时空并排前行。偶尔企图靠近，却不舍丢弃属于自己的轨迹 曾经只是曾经。有时还是会想起，却永远不会有机会拾起没有了最初的悸动，过去也只是过去释怀是一种态度，很佩服彼此的决绝可能这正是我们所需要的，捅破了心灵的窗纱，寻到了透明的真实。很残酷，但还好不过是阵痛罢了 四月是我们彼此的切角，隔绝了视线，竖起了通往对方心灵的单向玻璃。我想我不会忘记，也不会再轻易提起。","categories":[],"tags":[{"name":"时光印记","slug":"时光印记","permalink":"https://capisy.github.io/tags/时光印记/"}]}]}